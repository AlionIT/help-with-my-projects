export { }; // Достаточно пустого экспорта - чтобы VsCode воспринимало файл как модуль и не обращало внимание на пересечение с именами внутри проекта где буду открывать этот файл
// символ ❌ в комментариях строки кода означает что данная строка выдает ошибку при нашей (почти максимальной) строгости TypeScript - если такую строку раскоментировать то она должна выдавать ошибку
// { эти блоки если они есть - нужны для экранирования имен переменных внутри блока }

/*
## 🛡️ Стандарты качества(строгости TypeScript) кода в этом файле:
*       Все примеры проверены с максимально возможно для учебных материалов строгими настройками TypeScript.
*       Этот справочник использует конфигурацию TypeScript уровня "Enterprise Strict":
*           *ВКЛЮЧЕНЫ ВСЕ STRICT ПРАВИЛА* (за исключением Группа 3: "noUnusedLocals") в файле tsconfig.ts в разделе
*           "🛡️ 4. БЛОК БЕЗОПАСНОСТИ И ТИПОВ (STRICTNESS): подразделы: 1, 2, 3".
*/





/**
╔═══════════════════════════════════════════════════════════════════════╗
║  ДВА ВАРИАНТА ОБЪЯВЛЕНИЯ ТИПОВ В TYPESCRIPT                           ║
╚═══════════════════════════════════════════════════════════════════════╝*/

/* Inline тип без создания type alias or interface - можно задать тип непосредственно при объявлении переменной */
{
    let httpStatus: 200 | 201 | 400 | 401 | 403 | 404 | 500 = 200;
    // Здесь union тип 200 | 201 | 400 | 401 | 403 | 404 | 500 задается прямо в объявлении переменной, без создания отдельного type alias 

    /*
        Inline типы следует использовать когда:
          * Одноразовое использование: Тип нужен только в одном месте и не будет переиспользоваться
          * Простые типы: Короткие union типы, которые легко читаются (например, string | number)
          * Локальный контекст: Тип специфичен для конкретной переменной и не имеет общего значения
    */
}



/* type | interface - создаем отдельную сущность Тип или Интерфейс имя всегда с большой буквы (не обязательно, но так принято и ясно что это Тип а не что-то другое) */
{
    type HttpStatus = 200 | 201 | 400 | 401 | 403 | 404 | 500;
    let httpStatus: HttpStatus = 200;

    /*
        Type alias (с созданием отдельного типа) следует использовать когда:
          * Переиспользование типа: Если тип используется в нескольких местах (несколько переменных, параметры функций, возвращаемые значения)
          * Сложные типы: Когда union тип длинный или сложный, и его inline объявление снижает читаемость кода
          * Документирование: Когда имя типа несет смысловую нагрузку и делает код более понятным
        */
}
/* Рекомендация: Если сомневаетесь с выбором inline or type | interface - начните с inline типа. Если заметите, что используете одинаковый тип в 2-3 местах — вынесите его в type | interface для улучшения поддерживаемости кода. */
/* interface or type - в чем отличия смотреть документ "interface or type.ts" */





/**
╔═══════════════════════════════════════════════╗
║  undefined null void В JAVASCRIPT/TYPESCRIPT  ║
╚═══════════════════════════════════════════════╝*/
/*

/*
void & undefined in JavaScript/TypeScript
┌─────────────────────────────────────┬──────────────────┬──────────────────┬────────────────────────────────┐
│ Аспект                              │ undefined        │ null             │ void                           │
├─────────────────────────────────────┼──────────────────┼──────────────────┼────────────────────────────────┤
│ Примитивный тип JavaScript?         │ ✅ Да (7-й)      │ ✅ Да (6-й)      │ ❌ Нет                        │
├─────────────────────────────────────┼──────────────────┼──────────────────┼────────────────────────────────┤
│ Существует в JavaScript runtime?    │ ✅ Да            │ ✅ Да            │ ❌ Нет                        │
├─────────────────────────────────────┼──────────────────┼──────────────────┼────────────────────────────────┤
│ Существует в TypeScript?            │ ✅ Да            │ ✅ Да            │ ✅ Да                         │
├─────────────────────────────────────┼──────────────────┼──────────────────┼────────────────────────────────┤
│ Compile-time тип                    │ ✅ Да            │ ✅ Да            │ ✅ Да                         │
├─────────────────────────────────────┼──────────────────┼──────────────────┼────────────────────────────────┤
│ Runtime значение                    │ ✅ undefined     │ ✅ null          │ ❌ → превращается в undefined │
├─────────────────────────────────────┼──────────────────┼──────────────────┼────────────────────────────────┤
│ Что реально в памяти?               │ undefined        │ null             │ undefined                      │
├─────────────────────────────────────┼──────────────────┼──────────────────┼────────────────────────────────┤
│ Можно присвоить переменной?         │ ✅ let x = ...   │ ✅ let x = ...   │ ⚠️ Бессмысленно               │
├─────────────────────────────────────┼──────────────────┼──────────────────┼────────────────────────────────┤
│ Тип возврата функции?               │ ⚠️ Плохая        │ ✅ Да            │ ✅ Стандарт                   │
│                                     │ практика         │ (для данных)     │ (для side effects)             │
├─────────────────────────────────────┼──────────────────┼──────────────────┼────────────────────────────────┤
│ typeof в JavaScript                 │ "undefined"      │ "object" (баг!)  │ ─ (не существует)              │
├─────────────────────────────────────┼──────────────────┼──────────────────┼────────────────────────────────┤
│ Проверка: === undefined/null        │ ✅ Да            │ ✅ Да            │ ❌ Нельзя (не значение)       │
├─────────────────────────────────────┼──────────────────┼──────────────────┼────────────────────────────────┤
│ После компиляции TS → JS            │ ✅ Остаётся      │ ✅ Остаётся      │ ❌ Удаляется (только тип)     │
├─────────────────────────────────────┼──────────────────┼──────────────────┼────────────────────────────────┤
│ Семантика для разработчика          │ "Ошибка/         │ "Пустота         │ "Функция не возвращает         │
│ (по твоим правилам)                 │ неконтролируемое │ заданная мною"   │ полезного значения"            │
│                                     │ значение"        │                  │                                │
├─────────────────────────────────────┼──────────────────┼──────────────────┼────────────────────────────────┤
│ Основное применение                 │ Автоматическое   │ Явное указание   │ Типизация функций              │
│                                     │ значение JS      │ отсутствия       │ без возврата                   │
└─────────────────────────────────────┴──────────────────┴──────────────────┴────────────────────────────────┘


💡 Не забываем:
    ✅ undefined (примитив JS)
    ✅ null (примитив JS)
    ✅ void (TypeScript концепция) - void НЕ примитивный тип JavaScript! Это TypeScript-специфичная концепция!
*/





/**
╔═══════════════════════════════════════════════════════════════════════╗
║  ТРИ УРОВНЯ ТИПОВ В TYPESCRIPT                                        ║
╚═══════════════════════════════════════════════════════════════════════╝*/
/*
Тип — это контроль действия
Типы не меняют поведение runtime.
Они: ограничивают:
    * что ты можешь написать (компилятор/IDE остановит),
    * подсказывают, что ты хотел (автокомплит),
    * помогают делать корректные проверки (narrowing в if/switch),
    * фиксируют контракт между модулями.

То есть это реально контроль кода на этапе написания, а не “действие” в runtime.
*/

/**1️⃣  LITERAL TYPE (самый узкий Тип) — const
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */
const literalType = "Hello";
// Тип: "Hello" (только это конкретное значение)





/**2️⃣  PRIMITIVE TYPE (самый широкий Тип) — let
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */
let primitiveType = "Hello";
// Тип: string (любая строка)





/**3️⃣  COMPOSITE TYPES Составные типы:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */
/*      * по Ширине охвата - зависят от конкретных типов в составе:
          * если они узкие (конкретные литеральные значения) - по ширине будут располагаться между Literal and Primitive types
          * если же они сами по себе Primitive Type то они даже шире чем Primitive Type */
/*
    СОСТАВНЫЕ ТИПЫ (построены из других типов) - группировку проводим по разделителю между типами, группами типов

    Все возможные комбинации Составных типов:
    ───────────────────────────────────────────────────────────────────────
    Название Типов                                                              Частота использования
    ├─ Union Type Простой (Literal | Literal ...)                               🔥🔥🔥🔥🔥 - повсеместно
    ├─ Union Type Простой (null | Literal ...)                                  🔥🔥🔥🔥🔥 — nullable, optional
    ├─ Union Type Составной (Group Literal | Group Literal ...)                 🔥🔥🔥     — группировка значений 
    ├─ Intersection Type (A & B)                                                🔥🔥🔥🔥   — миксины, расширение
    ├─ Object Type ({ ... })                                                    🔥🔥🔥🔥🔥 — модели, API, конфиг
    ├─ Array Type ([...])                                                       🔥🔥🔥🔥🔥 — списки, коллекции
    ├─ Tuple Type ([A, B])                                                      🔥🔥       — React hooks, координаты
    ├─ Function Type                                                            🔥🔥🔥🔥   — callbacks, handlers
    └─ Generic Type                                                             🔥🔥🔥     — переиспользование
*/





/**3️⃣.1️⃣  Union Type Простой (Literal | Literal ...) - let с явно заданными литеральными значениями */

let unionType: "Hello" | "World" = "Hello";
// Тип: "Hello" | "World" (только эти 2 значения)
unionType = "Hello"; // ✅ допустимое значение для переменной задано в ее Union типе
unionType = "World"; // ✅ допустимое значение для переменной задано в ее Union типе
// unionType = "Привет"; // ❌ ERROR! Такого значения нет в Union типе заданном для переменной

// Размеры кнопок, шрифтов, отступов
type Size = "small" | "medium" | "large";
let buttonSize: Size = "medium";
buttonSize = "large";      // ✅ OK
// buttonSize = "huge";    // ❌ ERROR!

// Размеры одежды
type ClothingSize = "XS" | "S" | "M" | "L" | "XL" | "XXL";
let shirtSize: ClothingSize = "L";

// Размеры экрана
type ScreenSize = "mobile" | "tablet" | "desktop" | "wide";
let currentScreen: ScreenSize = "desktop";

type Theme = "light" | "dark" | "auto";
let appTheme: Theme = "dark";

// Режим отображения
type ViewMode = "grid" | "list" | "compact";
let viewMode: ViewMode = "grid";

// Язык интерфейса
type Language = "en" | "ru" | "es" | "fr" | "de";
let currentLang: Language = "ru";

// Способы оплаты
type PaymentMethod = "card" | "paypal" | "apple_pay" | "google_pay" | "cash";
let payment: PaymentMethod = "card";

// Валюты
type Currency = "USD" | "EUR" | "GBP" | "RUB";
let currency: Currency = "USD";

// Статус оплаты
type PaymentStatus = "pending" | "processing" | "completed" | "failed" | "refunded";
let paymentStatus: PaymentStatus = "completed";

// Типы событий
type EventType = "click" | "hover" | "focus" | "blur" | "submit";

let eventType: EventType = "click";

// Действия пользователя
type UserAction = "login" | "logout" | "signup" | "update_profile" | "delete_account";
let action: UserAction = "login";

// Типы уведомлений
type NotificationType = "info" | "success" | "warning" | "error";
let notificationType: NotificationType = "success";

type HttpMethod = "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
let method: HttpMethod = "POST";

// HTTP статус коды (популярные)
type HttpStatus = 200 | 201 | 400 | 401 | 403 | 404 | 500;
let statusCode: HttpStatus = 200;
statusCode = 404;          // ✅ OK
// statusCode = 999;       // ❌ ERROR!

// Content-Type
type ContentType = "application/json" | "application/xml" | "text/plain" | "multipart/form-data";
let contentType: ContentType = "application/json";


// 💡 КОГДА ИСПОЛЬЗОВАТЬ UNION ПРОСТОЙ:
// • Значение может быть ОДНИМ из вариантов
// • Варианты не выделяются в отдельные группы





/**3️⃣.2️⃣  Union Type Простой (null | Literal ...) - let с явно заданными литеральными значениями и null */

/* ═════════════════════════════════════════════════════════════
   БАЗОВЫЙ СИНТАКСИС
   ═════════════════════════════════════════════════════════════ */
{
    let status: "loading" | "success" | "error" = "loading";
    //          ^^^^^^^^^   ^^^^^^^^^   ^^^^^^^ - только эти 3 значения!

    let count: 0 | 1 | 2 | 3 = 0;
    //         ^   ^   ^   ^ - только эти числа!

    let flag: true | false = true;
    //        ^^^^   ^^^^^ - boolean через union (не обязательно, но можно)
}

/* ═════════════════════════════════════════════════════════════
   С NULL (самый частый паттерн!)
   ═════════════════════════════════════════════════════════════ */
{
    let userId: string | null = null;
    //          ^^^^^^   ^^^^ - строка ИЛИ пустота

    let theme: "light" | "dark" | null = null;
    //         ^^^^^^^   ^^^^^^   ^^^^ - одна из тем ИЛИ не выбрана

    let size: "small" | "medium" | "large" | null = "medium";
    //        ^^^^^^^   ^^^^^^^^   ^^^^^^^   ^^^^ - размер ИЛИ не задан
}

/* ═════════════════════════════════════════════════════════════
   КОМБИНАЦИИ ТИПОВ
   ═════════════════════════════════════════════════════════════ */
{
    let value: string | number | null = null;
    //         ^^^^^^   ^^^^^^   ^^^^ - строка, число или пустота

    let mixed: "auto" | 100 | true | null = "auto";
    //         ^^^^^^   ^^^   ^^^^   ^^^^ - разные литералы + null
}

/* ═════════════════════════════════════════════════════════════
   ПРОВЕРКА И ИСПОЛЬЗОВАНИЕ
   ═════════════════════════════════════════════════════════════ */
{
    let status: "active" | "inactive" | null = "active";

    if (status !== null) {
        console.log((status as string).toUpperCase()); // ✅ OK
        //           ^^^^^^^^^^^^^^^^^^
        //           Говорим TS: "это обычная строка"
    }


    // Присвоение:
    status = "active";   // ✅ OK
    status = "inactive"; // ✅ OK
    status = null;       // ✅ OK
    // status = "pending"; // ❌ ERROR! Нет в union
}


/* ═════════════════════════════════════════════════════════════
   💡 ЗАЧЕМ NULL В UNION TYPE?
   ═════════════════════════════════════════════════════════════
   
   1. ОТСУТСТВИЕ ВЫБОРА
      let theme: "light" | "dark" | null = null;
      • Пользователь ещё не выбрал тему → null
      • Выбрал → "light" или "dark"
   
   2. НАЧАЛЬНОЕ СОСТОЯНИЕ
      let userId: string | null = null;
      • Пока не авторизован → null
      • После входа → "user-123"
   
   3. ОПЦИОНАЛЬНЫЕ ДАННЫЕ
      let avatar: string | null = null;
      • Аватар не загружен → null
      • Загружен → "/path/to/avatar.jpg"
   
   4. РЕЗУЛЬТАТ ПОИСКА
      let found: "item1" | "item2" | null = searchResult();
      • Не найдено → null
      • Найдено → конкретное значение
   
   5. ЯВНАЯ ПУСТОТА vs undefined
      • null = "я задумал пустоту"
      • undefined = "ошибка/неконтролируемое"
   
   ✅ ПАТТЕРН: Literal | ... | null
   • Набор конкретных значений + пустота
   • Типобезопасность + гибкость
   • Явная семантика (null = намеренная пустота)
   
   ⭐ ПОЧЕМУ ПОПУЛЯРЕН:
   • Читаемость: сразу видны все возможные значения
   • Безопасность: TypeScript запрещает другие значения
   • Явность: null показывает "значение может отсутствовать"
   • Проверяемость: компилятор требует проверку !== null
   ═════════════════════════════════════════════════════════════ */


/* ═════════════════════════════════════════════════════════════
   РЕАЛЬНЫЕ ПРИМЕРЫ
   ═════════════════════════════════════════════════════════════ */
{
    // UI компонент:
    let buttonSize: "small" | "medium" | "large" | null = null;

    // API статус:
    let requestStatus: "idle" | "pending" | "success" | "error" | null = "idle";

    // Выбор пользователя:
    let selectedColor: "red" | "green" | "blue" | null = null;

    // Роль пользователя:
    let userRole: "admin" | "user" | "guest" | null = null;

    // Сортировка:
    let sortOrder: "asc" | "desc" | null = null;

}
/* ═════════════════════════════════════════════════════════════
   🎯 КРАТКИЙ ИТОГ
   ═════════════════════════════════════════════════════════════
   
   Literal | Literal | ... | null
           ^                 ^^^^
           |                 └─ Явная пустота (намеренная)
           └─ Точные значения (ограничение)
   
   ✅ Для: состояния, выборы, статусы, конфигурация
   ✅ null: начальное значение или "не задано"
   ✅ TypeScript: автокомплит + защита от ошибок
   ═════════════════════════════════════════════════════════════ */





/**3️⃣.3️⃣  Union Type Составной (Group Literal | Group Literal ...) - let с заданными Group Literal в качестве значении */
/* ═════════════════════════════════════════════════════════════
   БАЗОВЫЙ СИНТАКСИС
   ═════════════════════════════════════════════════════════════ */
{
    let response: { success: true; data: string } | { success: false; error: string };
    //            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    //            Группа 1: успех                      Группа 2: ошибка

    response = { success: true, data: "OK" };        // ✅ Группа 1
    response = { success: false, error: "Failed" };  // ✅ Группа 2
}

/* ═════════════════════════════════════════════════════════════
   С NULL (часто для начального состояния)
   ═════════════════════════════════════════════════════════════ */
{
    let result: { status: "ok"; value: number } | { status: "error"; message: string } | null = null;
    //          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^
    //          Группа 1: успешный результат      Группа 2: ошибка                         null

    result = { status: "ok", value: 42 };              // ✅ Группа 1
    result = { status: "error", message: "Fail" };     // ✅ Группа 2
    result = null;                                     // ✅ Начальное состояние
}

/* ═════════════════════════════════════════════════════════════
   ДИСКРИМИНИРУЕМЫЕ UNION (Tagged Union)
   ═════════════════════════════════════════════════════════════ */
{
    type LoadingState = { type: "loading" };
    type SuccessState = { type: "success"; data: string };
    type ErrorState = { type: "error"; error: string };

    let state: LoadingState | SuccessState | ErrorState | null = null;
    //         ^^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^^^   ^^^^
    //         Группа 1        Группа 2        Группа 3     null

    state = { type: "loading" };                    // ✅ Группа 1
    state = { type: "success", data: "Hello" };     // ✅ Группа 2
    state = { type: "error", error: "Failed" };     // ✅ Группа 3
}

/* ═════════════════════════════════════════════════════════════
   ПРОВЕРКА И ИСПОЛЬЗОВАНИЕ (Type Guard) - ❌ ERROR Надо еще разбираться с ошибками...
   ═════════════════════════════════════════════════════════════ */
{
    let response: { success: true; data: string } | { success: false; error: string } | null = null;

    if (response !== null) {
        if (response.success) {
            console.log(response.data);   // TypeScript знает: это { success: true; data: string }
        } else {
            console.log(response.error);  // TypeScript знает: это { success: false; error: string }
        }
    }
}

/* ═════════════════════════════════════════════════════════════
   💡 ЗАЧЕМ GROUP LITERAL UNION?
   ═════════════════════════════════════════════════════════════
   
   1. ВЗАИМОИСКЛЮЧАЮЩИЕ СОСТОЯНИЯ
      { success: true; data: T } | { success: false; error: E }
      • Либо успех с данными
      • Либо ошибка с сообщением
      • НЕ может быть одновременно!
   
   2. РАЗНЫЕ ФОРМЫ ДАННЫХ
      { type: "circle"; radius: number } | { type: "square"; side: number }
      • Круг имеет радиус
      • Квадрат имеет сторону
      • Разные свойства для разных типов
   
   3. СОСТОЯНИЯ ЗАГРУЗКИ
      { status: "loading" } | { status: "success"; data: T } | { status: "error"; error: E }
      • Загрузка: нет данных
      • Успех: есть данные
      • Ошибка: есть сообщение об ошибке
   
   4. API ОТВЕТЫ
      { ok: true; result: Data } | { ok: false; reason: string }
      • Успешный ответ с результатом
      • Неудача с причиной
   
   5. ТИПОБЕЗОПАСНОСТЬ
      • TypeScript проверяет: все свойства присутствуют
      • Нельзя смешать { success: true; error: "..." } ❌
      • Автокомплит показывает правильные поля
   
   ⭐ ПОЧЕМУ ПОПУЛЯРЕН:
   • Discriminated Union: type/status/kind = дискриминатор
   • Type Narrowing: TypeScript автоматически сужает тип
   • Невозможность невалидных состояний
   • Явная логика: либо A, либо B (не "и то, и то")
   
   🎯 ПАТТЕРН: Result<T, E>
   type Result<T, E> = 
     | { success: true; value: T } 
     | { success: false; error: E };
   
   • Rust-like подход к обработке ошибок
   • Явная проверка результата
   • Нет try-catch (функциональный стиль)
   ═════════════════════════════════════════════════════════════ */


/* ═════════════════════════════════════════════════════════════
   РЕАЛЬНЫЕ ПРИМЕРЫ - ❌ ERROR Надо еще разбираться с ошибками...
   ═════════════════════════════════════════════════════════════ */
{
    // API Response:
    let apiResult: { ok: true; data: User } | { ok: false; error: string } | null = null;

    // Async State:
    let asyncData:
        | { state: "idle" }
        | { state: "loading" }
        | { state: "success"; data: string }
        | { state: "error"; error: string }
        | null = { state: "idle" };

    // Shape (геометрия):
    let shape:
        | { kind: "circle"; radius: number }
        | { kind: "square"; side: number }
        | { kind: "rectangle"; width: number; height: number }
        | null = null;

    // Payment Method:
    let payment:
        | { method: "card"; cardNumber: string; cvv: string }
        | { method: "paypal"; email: string }
        | { method: "cash" }
        | null = null;

    // WebSocket Message:
    let message:
        | { type: "connect"; userId: string }
        | { type: "message"; text: string; timestamp: number }
        | { type: "disconnect"; reason: string }
        | null = null;
}

/* ═════════════════════════════════════════════════════════════
   ADVANCED: Type Alias для переиспользования - ❌ ERROR Надо еще разбираться с ошибками...
   ═════════════════════════════════════════════════════════════ */
{
    type Success<T> = { success: true; data: T };
    type Failure = { success: false; error: string };
    type Result<T> = Success<T> | Failure | null;

    let userResult: Result<User> = null;
    let productResult: Result<Product> = null;
    // Переиспользуем паттерн для разных типов данных!
}

/* ═════════════════════════════════════════════════════════════
   🎯 КРАТКИЙ ИТОГ
   ═════════════════════════════════════════════════════════════
   
   { group1 } | { group2 } | ... | null
    ^^^^^^^^    ^^^^^^^^          ^^^^
    |           |                 └─ Начальное/пустое состояние
    |           └─ Альтернативная структура
    └─ Одна структура данных
   
   ✅ Для: API ответы, состояния, формы данных, события
   ✅ Дискриминатор: type/status/kind для различения
   ✅ TypeScript: автосужение типа + защита от невалидных состояний
   ✅ null: "данных пока нет" (начальное состояние)
   
   🔥 МОЩЬ: Невозможно создать невалидное состояние!
   ═════════════════════════════════════════════════════════════ */










/** ПРОДОЛЖУ В ДАЛЬНЕЙШЕМ ПО ХОДУ РАБОТЫ КОГДА БУДУ ПРАКТИЧЕСКИ ПРИМЕНЯТЬ ПРИМЕРЫ НИЖЕ
├─ Intersection Type (A & B)                                                🔥🔥🔥🔥   — миксины, расширение
├─ Object Type ({ ... })                                                    🔥🔥🔥🔥🔥 — модели, API, конфиг
├─ Array Type ([...])                                                       🔥🔥🔥🔥🔥 — списки, коллекции
├─ Tuple Type ([A, B])                                                      🔥🔥       — React hooks, координаты
├─ Function Type                                                            🔥🔥🔥🔥   — callbacks, handlers
└─ Generic Type                                                             🔥🔥🔥     — переиспользование
*/
