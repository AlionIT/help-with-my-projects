export { }; // Достаточно пустого экспорта - чтобы VsCode воспринимало файл как модуль и не обращало внимание на пересечение с именами внутри проекта где буду открывать этот файл
// символ ❌ в комментариях строки кода означает что данная строка выдает ошибку при нашей (почти максимальной) строгости TypeScript - если такую строку раскоментировать то она должна выдавать ошибку
// { эти блоки если они есть - нужны для экранирования имен переменных внутри блока }

/*
## 🛡️ Стандарты качества(строгости TypeScript) кода в этом файле:
*       Все примеры проверены с максимально возможно для учебных материалов строгими настройками TypeScript.
*       Этот справочник использует конфигурацию TypeScript уровня "Enterprise Strict":
*           *ВКЛЮЧЕНЫ ВСЕ STRICT ПРАВИЛА* (за исключением Группа 3: "noUnusedLocals") в файле tsconfig.ts в разделе
*           "🛡️ 4. БЛОК БЕЗОПАСНОСТИ И ТИПОВ (STRICTNESS): подразделы: 1, 2, 3".
*/



/**
╔════════════════════════════════════════╗
║  Мои правила: null | void | undefined  ║
╚════════════════════════════════════════╝*/
/*
Мои правила:
    * ⚫ null = Пустота заданная мною - если в переменной, свойстве объекта, возврате из функции - значение === null - это я так задумал и никакой ошибки тут нет - это значит что ответа, значения просто нет - ПУСТОТА.
    * ⚪ void = дополнительный к null тип применяемый для конструирования функции
    * ❌ undefined = это ошибка - если я получаю значение === undefined это для меня означает ошибку - это не мой ответ а ошибочно возникшее значение которое я не контролирую

Что дают мой правила:
    * undefined очень распространен в JavaScript и в случае получения значения  === undefined не понятно откуда оно взялось - это стандартное значение возвращаемое JavaScriprt или же это моя заданная пустота.
    * Так родилось желание различать пустоту заданую мною и пустоту существующую повсеместно в JavaScript

Почему такое несовершенство в JavaScript:
    * JavaScript создан в 1995 году
    * undefined - встроенное поведение языка:
        - Переменная без значения → undefined
        - Несуществующее свойство → undefined
        - Функция без return → undefined
        - Array.find() не нашёл → undefined
        ...
    😪 Это НЕЛЬЗЯ изменить (часть спецификации JavaScript!)


    💡 РЕШЕНИЕ:
        * Соблюдать Правила использования null | void | undefined в данном документе
        * Использовать инструменты конвертации undefined → null там где undefined все равно возникает не смотря на все предосторожности с моей стороны
*/





/**
╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║  Защита от случайно возникшего undefined - Откуда берется  undefined и как с ним бороться и что делать если undefined неизбежен  ║
╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝*/

/** 1. Переменные без значения подсвечиваются ошибкой 🔴 TypeScript СТРОГО контролирует undefined: 
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */

let id: string; // ⚠️ НЕ инициализировали! id === undefined - Объявили, Но Забыли инициализировать - ОШИБКА!
// Суть: Ты создал "коробку", но ничего туда не положил.
// JavaScript автоматически кладет туда undefined.
// console.log(id); // ❌ Error при наших настройках строгости TS, но TS промолчит если строгость снизить и будет "strictNullChecks": false, поэтому никогда так не делаем

/* Лечение: */
/* a. Всегда инициализировать (= null).*/
let username: string | null = null;  // Сразу инициализировали с null
let username2: string | undefined = undefined; // ⚠️💥 НЕЛЬЗЯ undefined задавать в качестве пустоты - Используем null!


/* b. Всегда высокая строгость TS - в tsconfig.ts: strictNullChecks": true, никогда не делаем false*/





/** 2. Несуществующее свойство объекта также подсвечивается ошибкой 🔴 ЗАЩИТА РАБОТАЕТ = (⚠️ТИП ОБЪЕКТА ≠ any) && (⚠️ТИП СВОЙСТВА известен) && (⚠️способ доступа)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */

/* ТИП САМОГО ОБЪЕКТА - ГЛАВНЫЙ ФАКТОР! */

// ⚠️ ОБЪЕКТ С ТИПОМ any → НЕТ ЗАЩИТЫ
const obj1: any = { name: "Alice" };
console.log(obj1.age);              // ⚠️✅ TS: OK, 💥 undefined пропустили
console.log(obj1.anything);         // ⚠️✅ TS: OK, 💥 undefined пропустили
console.log(obj1.foo.bar.baz);      // ⚠️✅ TS: OK, 💥 TypeError - 


// ✅ ОБЪЕКТ С КОНКРЕТНЫМ ТИПОМ → ЕСТЬ ЗАЩИТА
const obj2: { name: string } = { name: "Alice" };
// console.log(obj2.age); // ❌ TS ERROR при обращении к несуществующему свойству объекта! ✅ Защищён!
// ✅ TypeScript знает структуру объекта!


// ✅ ОБЪЕКТ С ИНТЕРФЕЙСОМ → ЕСТЬ ЗАЩИТА
interface User {
    name: string;
    id: string;
}
const obj3: User = { name: "Alice", id: "123" };
// console.log(obj3.email); // ❌ TS ERROR при обращении к несуществующему свойству объекта! ✅ Защищён!


// ✅ ОБЪЕКТ С type → ЕСТЬ ЗАЩИТА
type Person = {
    name: string;
    age: number;
};
const obj4: Person = { name: "Alice", age: 25 };
// console.log(obj4.email); // ❌ TS ERROR при обращении к несуществующему свойству! ✅ Защищён!





/** 3. Функция, которая "молчит" - Это очень частый источник undefined, о котором стоит знать.
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */

//  Ситуация: Функция выполнила действие, но у неё нет слова return.
{
    function saveUser() {
        console.log("Сохраняю...");
        // Нет return!
    }

    let result = saveUser();
    console.log(result); // Выведет: undefined
}

/* Лечение: */

/* 1. Различай void и undefined */
// void = "функция не возвращает полезного значения" (compile-time тип)
// undefined = конкретное значение в JavaScript (runtime значение)

// void ≠ undefined - это разные концепции!



/* 2. Используй void для side-effect функций */
{
    function saveUser(): void { } // ✅ Сохранение в БД
    function logError(): void { } // ✅ Логирование
    function sendEmail(): void { } // ✅ Отправка данных
    function updateUI(): void { } // ✅ Обновление интерфейса
}



/* 3. Используй null для отсутствующих значений */
{
    type User = { id: string; name: string };

    // Вариант 1: Добавить return
    function findUser1(): User | null {
        return null; // ✅ OK
    }
}



/* 4. НЕ присваивай результат void функций */
{
    function saveUser(): void {
        console.log("Saving...");
    }

    const result = saveUser(); // ❌ ЗАПРЕЩЕНО!
    saveUser(); // ✅ ПРАВИЛЬНО
}



/* 5. Если нужен результат операции - НЕ используй void */
{
    type User = { id: string; name: string };
    type Result<T> = { success: true; value: T } | { success: false; error: string };

    function saveUser(): void { } // ✅ OK (void может быть пустой)

    function saveUser1(): boolean {
        return true; // ✅ return!
    }

    function saveUser2(): Result<User> {
        return { success: true, value: { id: "1", name: "Alice" } }; // ✅ return!
    }
}





/** 4. ВСТРОЕННЫЕ МЕТОДЫ JAVASCRIPT возвращают undefined
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ */

/** Array.find() → возвращает T | undefined */
{
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ⚠️ ПРОБЛЕМА: Array.find() возвращает undefined
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    
    type User = { id: string; name: string };
    
    const users: User[] = [
        { id: "1", name: "Alice" },
        { id: "2", name: "Bob" }
    ];

    const user = users.find(u => u.id === "3");
    //    ^^^^ тип: User | undefined ⚠️
    //    Элемент не найден → возвращает undefined
    
    console.log(user);  // undefined в runtime

    // ⚠️ ПРОБЛЕМА: Нарушает правило проекта "нет undefined"!



    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ✅ РЕШЕНИЕ: Конвертация undefined → null (?? оператор)
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    
    const userSafe = users.find(u => u.id === "3") ?? null;
    //                                              ^^ Nullish Coalescing оператор
    //    ^^^^^^^^ тип: User | null ✅
    
    console.log(userSafe);  // null (не undefined!)

    // Проверка:
    if (userSafe !== null) {
        console.log(userSafe.name.toUpperCase());  // User
    }


    // Примеры использования:
    const alice = users.find(u => u.name === "Alice") ?? null;
    const bob = users.find(u => u.id === "2") ?? null;
    const notFound = users.find(u => u.id === "999") ?? null;

    if (alice !== null) {
        console.log(`Found: ${alice.name}`);
    }



    /* ═════════════════════════════════════════════════════════════
       💡 ВЫВОДЫ:
       ═════════════════════════════════════════════════════════════
       
       1. Array.find() → возвращает T | undefined ⚠️
          • Встроенное поведение JavaScript (нельзя изменить)
          • Нарушает правило "нет undefined"
       
       2. Основное решение: array.find(...) ?? null ✅
          • Самый простой и частый способ
          • Использовать везде где нужен null
          • Конвертирует undefined → null автоматически
       
       3. Для продвинутых случаев:
          
          • Helper функция findOrNull(array, predicate)
            - Переиспользуемая логика для всего проекта
            - Более явная семантика в коде
          
          • Специализированные helpers (findById, findByName)
            - Типобезопасные функции для частых поисков
            - Упрощают код и уменьшают дублирование
          
          • Расширение Array.prototype.findOrNull()
            - Для больших проектов с единым стандартом
            - Осторожно: изменяет глобальный прототип
            - Только если это соглашение команды
       
       ⚠️ НЕ используй filter()[0] вместо find()
          • Менее эффективно (проходит весь массив)
          • Всё равно возвращает undefined
          • find() останавливается на первом совпадении
       
       🎯 РЕКОМЕНДАЦИЯ:
       • Для 99% случаев → array.find(...) ?? null ✅
       • Для переиспользования → создай helper функцию
       • Для больших проектов → обсуди с командой prototype расширение
    */
}





/** Map.get() → возвращает V | undefined */
{
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ⚠️ ПРОБЛЕМА: Map.get() возвращает undefined
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    
    const cache = new Map<string, string>();
    cache.set("key1", "value1");

    const value = cache.get("key2");
    //    ^^^^^ тип: string | undefined ⚠️
    //    Ключ не существует → возвращает undefined
    
    console.log(value);  // undefined в runtime

    // ⚠️ ПРОБЛЕМА: Нарушает правило проекта "нет undefined"!



    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ✅ РЕШЕНИЕ: Конвертация undefined → null (?? оператор)
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    
    const valueSafe = cache.get("key2") ?? null;
    //                                  ^^ Nullish Coalescing оператор
    //    ^^^^^^^^^ тип: string | null ✅
    
    console.log(valueSafe);  // null (не undefined!)

    // Проверка:
    if (valueSafe !== null) {
        console.log(valueSafe.toUpperCase());  // string
    }


    // Примеры использования:
    const userCache = new Map<string, { id: string; name: string }>();
    userCache.set("1", { id: "1", name: "Alice" });

    const user1 = userCache.get("1") ?? null;    // { id: "1", name: "Alice" }
    const user2 = userCache.get("999") ?? null;  // null

    if (user1 !== null) {
        console.log(`User: ${user1.name}`);
    }



    /* ═════════════════════════════════════════════════════════════
       💡 ВЫВОДЫ:
       ═════════════════════════════════════════════════════════════
       
       1. Map.get() → возвращает V | undefined ⚠️
          • Встроенное поведение JavaScript (нельзя изменить)
          • Нарушает правило "нет undefined"
       
       2. Основное решение: map.get(key) ?? null ✅
          • Самый простой и частый способ
          • Использовать везде где нужен null
          • Конвертирует undefined → null автоматически
       
       3. Для продвинутых случаев:
          
          • Helper функция getOrNull(map, key)
            - Переиспользуемая логика для всего проекта
            - Более явная семантика в коде
          
          • Wrapper класс SafeMap<K, V>
            - Обёртка над Map с автоматической конвертацией
            - get() возвращает V | null вместо V | undefined
            - Единообразный API для всего проекта
          
          • Расширение Map.prototype.getOrNull()
            - Для больших проектов с единым стандартом
            - Осторожно: изменяет глобальный прототип
            - Только если это соглашение команды
       
       ⚠️ map.has() не помогает с типами
          • TypeScript НЕ сужает тип после has()
          • Всё равно нужна проверка или ?? null
       
       🎯 РЕКОМЕНДАЦИЯ:
       • Для 99% случаев → map.get(key) ?? null ✅
       • Для переиспользования → создай helper getOrNull()
       • Для больших проектов → обсуди SafeMap wrapper класс
    */
}





/** Object c Optional свойством может привести к undefined - T | undefined */
{
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ⚠️ ПРОБЛЕМНЫЙ ВАРИАНТ: Optional (?)
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    type Config = {
        host: string;
        port: number;
        database?: string;  // Optional свойство
        //       ^ Может отсутствовать → undefined
    };

    const config: Config = {
        host: "localhost",
        port: 3000
        // database не указываем (optional = может отсутствовать)
    };

    const database = config.database;
    //    ^^^^^^^^ тип: string | undefined ⚠️

    console.log(database);  // undefined в runtime

    // ⚠️ ПРОБЛЕМА: Нарушает правило проекта "нет undefined"!



    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ✅ РЕШЕНИЕ 1: Конвертация undefined → null (??  оператор)
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    const db = config.database ?? null;
    //                         ^^ Nullish Coalescing оператор
    //    ^^ тип: string | null ✅



    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ✅ РЕШЕНИЕ 2 (ЛУЧШЕ): Обязательное свойство с null
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    type Config2 = {
        host: string;
        port: number;
        database: string | null;  // Обязательное, но может быть null
        //       ^^^^^^^^^^^^^^ НЕТ ? → свойство ОБЯЗАТЕЛЬНО
    };

    const config2: Config2 = {
        host: "localhost",
        port: 3000,
        database: null  // ✅ ДОЛЖНЫ явно указать (null или строку)
    };

    const db2 = config2.database;
    //    ^^^ тип: string | null ✅ (только ДВА варианта, нет undefined!)

    // Проверка:
    if (db2 !== null) {
        console.log(db2.toUpperCase());  // string
    }



    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ❌ АНТИПАТТЕРН: НЕ используй ?: ... | null (ТРИ типа!)
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    type ConfigBad = {
        database?: string | null;  // ❌ ПЛОХО!
        //       ^         ^^^^
        //       |         └─ может быть null
        //       └─ может отсутствовать (undefined)
    };

    const configBad: ConfigBad = { database: null };
    const dbBad = configBad.database;
    //    ^^^^^ тип: string | null | undefined ❌
    //    ТРИ варианта! Хуже всего!



    /* ═════════════════════════════════════════════════════════════
       💡 ВЫВОДЫ:
       ═════════════════════════════════════════════════════════════
       
       1. Optional свойство (?) → возвращает T | undefined ⚠️
          • Нарушает правило "нет undefined"
          • Требует конвертации: value ?? null
       
       2. Обязательное с null → возвращает T | null ✅
          • Соответствует правилу проекта
          • Явность: всегда указываем значение
          • Нет необходимости в конвертации
       
       3. НЕ комбинируй ?: ... | null → три типа ❌
          • string | null | undefined (хуже всего!)
       
       🎯 РЕКОМЕНДАЦИЯ:
       • Для объектов данных → database: string | null ✅
       • Для параметров функций → param?: string (внутри ?? null) ⚠️
       • НИКОГДА → database?: string | null ❌
    */
}
